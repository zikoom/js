 Value Types and Reference Types 에 관한 글들
================================================


Explaining Value vs. Reference in Javascript
--------------------------------------------
링크: <https://codeburst.io/explaining-value-vs-reference-in-javascript-647a975e12a0>

자바스크립트의 타입은 **원시** 값과 **객체** 로 이루어져있다. 자바스크립트에 존재하는 모든 변수는 이 두타입중 하나이다. 이 두타입의 변수가 가지는 결정적인 차이는 각종류의 값을 변수에 할당 할때, 실제로 저장되는 값이 무엇인가? 이다.

원시 타입에는 . ``Boolean``,``null``, ``undefined``, ``String``, ``Number`` 이 있고 __값__ 그자체를 저장한다.

```javascript
let val = 10;
```

-> 변수 val이 가리키고있는 메모리 공간에 가보면 실제로 값 10 이 저장되어있다.

```javascript
let object= {};
```

반면에 변수 object가 가리키고 있는 메모리공간에 가보면, 변수에 저장된 값이 __object__ 객체 그 자체가 아니라, __object객체의 메모리 상의 주소값__ 이 저장되어있다.

사실 이 차이만 이해하면 변수 타입에 대해서는 특별히 더 할말이 없다.
* 자바스크립트에는 두가지 종류의 값 이 있다. 원시값, 객체값
* 변수에 값을 할당 할때, 원시값, 객체값 모두 '='키워드로 오른쪽에서 왼쪽으로 할당한다. let a = 10,   let b = {};
* 할당하는 키워드는 같지만, 할당하려는 '값'의 종류에 따라 실제로 할당되는 값의 __종류__ 가 달라지게 된다. 원시값은 __값__ 그 자체가 할당되고,  객체 값은 __해당 객체의 메모리 상에서의 주소값__ 이 할당된다.



>  **원시타입(Primitives)**




```javascript
let a = 10;
let b = a;

let b = b + 30;

console.log(a, b);
// 10, 40
```

b 에다가 최초로 값을 할당할 때, a 를 이용하여 할당했다. 이후 b를 아무리 변경해도 a 값은 변하지 않는다. a 와 b에 저장된 값은 원시 값이고, 이 원시값은 각각 다른 메모리 상에 위치하기 때문이다. 여타 설명 필요없이 그냥 눈으로 봐도 당연하다고 여겨질만한 부분이다.



> **객체타입(Object)**

```javascript
let arr = [];
let copy = arr;

copy.push(1);
console.log(arr, copy);
//[1]  [1]
```


참조 타입 중 하나인 배열로 비슷한 예시코드를 작성해 보았다. 빈 배열을 사용해 arr 을 초기화하고, 이 arr을 이용해 copy를 초기화 했다. 그리고 copy 배열에 1을 push하고 arr 과 copy를 콘솔에 출력해보면...

어째서인지 arr, copy 배열 모두 [1]이다. 객체 타입의 변수가 가지는 값이 참조 값이라는 걸 모르면 어리둥절 할 수도 있다. 하지만 이 사실을 알고있다면, 원리는 간단하게 이해할 수 있다.

arr과 copy가 가지는 값이 같다 -> 참조하는 객체가 같다 -> copy.push(1)은 copy가 참조하고 있는 객체를 수정한다 -> arr이 참조하던 객체가 수정되었다.

여기에 더해서, console.log로 객체 값을 파라메터로 넘겨 실행하면, 해당 변수가 가지고 있는 참조 값을 기반으로 메모리에 있는 실제 객체 데이터를 가져온다는 것을 알 수 있다. (이부분의 정확한 원리는 본인은 잘 모름. 다만 차이가 있다는 사실은 알 수 있다.) 반면에 원시 타입 변수를 console.log 파라메터로 넘겨 실행하면, 원시 값을 출력해준다.

--------------------------------

상대적으로 더 이해하기 쉽지 않은 객체 타입 변수에 대해 조금더 이야기해 보겠다.


> == 과 ===

```javascript
let arr = [1,2,3];
let copy = arr;
console.log(arr === copy);
//true
```
copy에는 [1,2,3]의 주소값이 복사 -> 할당되었다.


> == 과 === 2
```javascript
let arr1 = ['hi'];
let isSame = ['hi'];
console.log(arr1 === isSame);
//false
```

arr1, isSame 변수는 각기 다른 객체를 참조하고있다. 같은['h1']이 할당되어서 두 변수가 같을 수도 있다고 생각할 수 있다. 하지만 객체 변수를 비교할 때 객체 내부의 데이터 내용은 비교 대상이 아니다. 객체 변수가 가지고 있는 값은 참조하는 객체의 주소값이다.