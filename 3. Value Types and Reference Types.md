 Value Types and Reference Types 에 관한 글들
================================================


Explaining Value vs. Reference in Javascript
--------------------------------------------
링크: <https://codeburst.io/explaining-value-vs-reference-in-javascript-647a975e12a0>

자바스크립트의 타입은 **원시** 값과 **객체** 로 이루어져있다.

원시 타입에는 . ``Boolean``,``null``, ``undefined``, ``String``, ``Number`` 이 있고 __값__ 으로서 전달된다.


원시 타입 외에는 **객체(object)** 가 있다. 함수, 객체, 배열이 객체타입 이다. 객체 타입은 **참조**로서 전달된다.


원시 타입과, 객체 타입의 변수가 가지는 가장 큰 차이는 가지고 있는 값의 **종류** 이다. 원시타입의 변수는 값 그자체를 가지고 있다. (숫자, 문자, 등등등)

객체타입의 변수는 특정 객체의 메모리상에서 **위치(주소)** 를 가지고있다.


위에서 말한 원시 타입과 객체 타입의 전달 방식에 차이가 나는 근본적인이유가, 애초에 각 타입의 변수가 가지고 있는 값의 종류가 다르게 설계되어있다. 즉 애초에 전달 방식에는 차이가 없다. 처음부터 다루는 값이 다르기 때문에, 주는 값의 종류에서 차이가 나게되고 마치 전달 방식에 차이가 있는 것 처럼 보인다. 하지만 **두 종류의 변수가 값을 전달하는 방법은 같다.** 가지고 있는 값의 종류가 다를 뿐이다. 값을 전달하는 방법은 간단하게, 복사해서 넘겨주게 된다.

어떤 변수를 이용해 다른 변수에 할당할때, 모든 변수는 자신이 가지고 있는 값을 주는 동일한 행동을 한다. 다만 그 값의 **종류** 가 다르기 때문에, 변수를 다루기 전 해당 변수의 타입을 확실히 할 필요가 있다.

>  **원시타입(Primitives)**




```javascript
let a = 10;
let b = a;

let b = b + 30;

console.log(a, b);
// 10, 40
```

b 에다가 최초로 값을 할당할 때, a 를 이용하여 할당했다. 이후 b를 아무리 변경해도 a 값은 변하지 않는다. a 와 b에 저장된 값은 원시 값이고, 이 원시값은 각각 다른 메모리 상에 위치하기 때문이다. 여타 설명 필요없이 그냥 눈으로 봐도 당연하다고 여겨질만한 부분이다.



> **객체타입(Object)**

```javascript
let arr = [];
let copy = arr;

copy.push(1);
console.log(arr, copy);
//[1]  [1]
```


참조 타입 중 하나인 배열로 비슷한 예시코드를 작성해 보았다. 빈 배열을 사용해 arr 을 초기화하고, 이 arr을 이용해 copy를 초기화 했다. 그리고 copy 배열에 1을 push하고 arr 과 copy를 콘솔에 출력해보면...

어째서인지 arr, copy 배열 모두 [1]이다. 객체 타입의 변수가 가지는 값이 참조 값이라는 걸 모르면 어리둥절 할 수도 있다. 하지만 이 사실을 알고있다면, 원리는 간단하게 이해할 수 있다.

arr과 copy가 가지는 값이 같다 -> 참조하는 객체가 같다 -> copy.push(1)은 copy가 참조하고 있는 객체를 수정한다 -> arr이 참조하던 객체가 수정되었다.

여기에 더해서, console.log로 객체 값을 파라메터로 넘겨 실행하면, 해당 변수가 가지고 있는 참조 값을 기반으로 메모리에 있는 실제 객체 데이터를 가져온다는 것을 알 수 있다. (이부분의 정확한 원리는 본인은 잘 모름. 다만 차이가 있다는 사실은 알 수 있다.) 반면에 원시 타입 변수를 console.log 파라메터로 넘겨 실행하면, 원시 값을 출력해준다.

--------------------------------

상대적으로 더 이해하기 쉽지 않은 객체 타입 변수에 대해 조금더 이야기해 보겠다.


> == 과 ===

```javascript
let arr = [1,2,3];
let copy = arr;
console.log(arr === copy);
//true
```
copy에는 [1,2,3]의 주소값이 복사 -> 할당되었다.


> == 과 === 2
```javascript
let arr1 = ['hi'];
let isSame = ['hi'];
console.log(arr1 === isSame);
//false
```

arr1, isSame 변수는 각기 다른 객체를 참조하고있다. 같은['h1']이 할당되어서 두 변수가 같을 수도 있다고 생각할 수 있다. 하지만 객체 변수를 비교할 때 객체 내부의 데이터 내용은 비교 대상이 아니다. 객체 변수가 가지고 있는 값은 참조하는 객체의 주소값이다.